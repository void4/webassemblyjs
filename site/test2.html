<meta charset="UTF-8">
<title>WasmJump</title>
<div style="width:30%;white-space: nowrap;display: inline-block;">.wast source</div>
<div style="width:30%;white-space: nowrap;display: inline-block;">wasm-metered</div>Snapshot<br>
<textarea style="width:30%;height:30%" id="input"></textarea>
<textarea style="width:30%;height:30%" id="met"></textarea>
<textarea style="width:30%;height:30%" id="snapshot"></textarea>
<div style="display:flex">
    <div style="width:45.5%;">
        <br>Arguments:<br>
        <input type="text" id="arg1" value="1">
        <input type="text" id="arg2" value="2">
        <button onclick="run()" >RUN</button>
        <br>
        <input type="text" id="ownid">
        <input type="text" id="peerid" placeholder="peerid">
        <button onclick="peerconnect()">Connect</button>
        <textarea style="width:30%;height:30%" id="peerinfo"></textarea>
        <div id="res"></div>
        <div id="info"></div>
    </div>
    <!--<script src="webassemblyjs@1.0.0-y.8.js"></script>-->
    <div style="width:50%;">
        <p align="center">
            <canvas id="canvas" style="border:solid;" width="256" height="256"></canvas>
        </p>
    </div>
</div>
<script src="libwabt.js"></script>
<script src="wasm-metering@0.2.1.js"></script>
<script src="bundle.js"></script>

<script src="peer.min.js"></script>

<script>

var input = document.getElementById("input")
var met = document.getElementById("met")
var snap = document.getElementById("snapshot")

var arg1 = document.getElementById("arg1")
var arg2 = document.getElementById("arg2")

var canvas = document.getElementById("canvas")

var peerinfo = document.getElementById("peerinfo")

var ctx = canvas.getContext("2d");
ctx.moveTo(0, 0);
ctx.lineTo(200, 100);
ctx.stroke();

//console.log("Setting up P2P")


var peerid = document.getElementById("peerid")
var ownid = document.getElementById("ownid")

var peer = new Peer();
peer.on('open', function(id) {
  //console.log('My peer ID is: ' + id);
  ownid.value = id
});

var peers = []

function updatePeers() {
  var peerids = peers.map(p=>p.id)
  peerinfo.value = peerids.join("\n")
  //console.log()
}

setInterval(updatePeers, 100)

function initConn(conn) {
  peers.push(conn)
  conn.on('data', function(data){
    // Will print 'hi!'
    console.log("DATA", data);
  });

  conn.on("close", function() {
    peers.splice(peers.indexOf(conn), 1)
  })
}

peer.on('connection', function(conn) {
  console.log("Connect")
  initConn(conn)
});


// Chooeses a random element from an array, uniformly
function choice(choices) {
  var index = Math.floor(Math.random() * choices.length);
  return choices[index];
}

function peerconnect() {
    var conn = peer.connect(peerid.value);
    conn.on('open', function() {
      initConn(conn)
      conn.send('Hello!');
    });
}

function sendToRandomPeer(data) {
  choice(peers).send(data)
}


input.value = `
(module
  (import "canvas" "draw" (func $draw (param i32 i32)))
  (func $custom
    (i32.const 150)
    (i32.const 150)
    (call $draw)
    )
  (export "add" (func $custom))
)
`

function print_i32(i) {
	//doesn't work due to strict mode
	//console.log(arguments.callee.caller)
	//console.log("RESULT", i)
	if (typeof i == "number") {
		var text = i
	} else {
		var text = i[0]._value
		if (i[0]._value == parseInt(arg2.value)) {
			info("Execution stopped.")
		}
	}
	document.getElementById("res").innerHTML = text
}


function debug(stack, framepointer) {
	var stack = JSON.parse(JSON.stringify(stack))
	//console.log(stack)
	for (var i=0;i<stack.length;i++) {
		stack[i].allocator = [stack[i].allocator.store, stack[i].allocator.offset]
	}
	//console.log(stack[0].originatingModule)
	snapshot = [input.value, stack, framepointer];
	var serialized = JSON.stringify(snapshot, null, 0)
  snap.value = serialized;
	//console.log(framepointer)
	console.log(JSON.stringify(stack, null, 4))
	//console.log(snapshot[1])
	//console.log(snapshot[0])
	info("Suspending execution. Resuming execution in 1 second.")
  sendToRandomPeer(serialized)
	setTimeout(resume, 1000)
	throw new Error("Suspended execution")
}

async function resume() {
	//info("")

	var stack = snapshot[1]
	console.log(stack)
	//var alloc = webassemblyjs.createAllocator()

	//var instance = webassemblyjs.instantiateFromSource(code, IO);
	var instance = await webassemblyjs.instantiate(metered, IO);
	var alloc = instance._allocator
	console.log("alloc", alloc)
	console.log(stack)
	alloc.store = stack[0].allocator[0]
	alloc.offset = stack[0].allocator[1]


	//console.log(instance._allocator.store)
	//instance._allocator = alloc
	//console.log(instance)
	for (var i=0;i<stack.length;i++) {
		console.log(stack[i])
		stack[i].allocator = alloc
		stack[i].originatingModule = instance._moduleInstance
	}


	webassemblyjs.executeStack(stack, 0)//snapshot[2])
	info("Finished execution.")
}

var snapshot = null;




function info(msg) {
	document.getElementById("info").innerHTML = msg
}

async function run() {
	info("Starting execution")
	//console.log(WebAssembly)
	//console.log(webassemblyjs)

	//var module = await webassemblyjs.instantiate(metered, IO);
    var instance = webassemblyjs.instantiateFromSource(met.value, IO);
	try {
		var res = instance.exports.add();//parseInt(arg1.value), parseInt(arg2.value)
		info("Result:", res);
	} catch (e) {
		console.log(e)
		console.log("Suspended execution")
	}

}

function usegas(arg) {
    var stack = JSON.stringify(arg[1], null, 4)
	console.log("usegas", arg[0], "FP", arg[2])
    snap.value = stack
}

function draw(a) {
    console.log(a)
    /*x1, y1, x2, y2
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();*/
}

var IO = {
    "system": {print_i32, debug},
    "metering": {usegas},
    "canvas": {draw}
}

var code = input.value;



var mod = wabt.parseWat('test.wat', code);
mod.resolveNames();
mod.validate();
//use wabt's wasm-interp?
var binary = mod.toBinary({log: false, write_debug_names:false})
var buffer = binary.buffer

var metered = wasmMetering.meterWASM(buffer).buffer//Buffer.from(
//var metered = buffer

//console.log(metered)
//console.log(buffer.length, metered.length)

// XXX Can't read debug names because wasm-metering doesn't insert symbols
var decoded = wabt.readWasm(metered, { readDebugNames: false })
//console.log(decoded)

var wast = decoded.toText({ foldExprs: false, inlineExport: false });
//console.log(wast)

var idregex = /\(;(\d+);\)/gi
var match = idregex.exec(wast)
while (match != null) {
    wast = wast.replace(match[0], "$"+match[1])
    wast = wast.replace("(func "+match[1], "$"+match[1])
    var match = idregex.exec(wast)
}

var lines = wast.split("\n")

var typedecls = {}

var result = []



for (var i=0;i<lines.length;i++) {
    var line = lines[i].trim()
    var typeprefix = "(type"

    var typeregex = /\(type (\d+)\)/gi
    // Assuming type declarations come before function declarations
    var importprefix = "(import "
    var exportprefix = "(export"

    var funcprefix = "(func"

    if (line.startsWith(typeprefix)) {
        var idlen = line.split(" ")[1].length
        //console.log(line.split(" "))
        var typedecl = line.substring(typeprefix.length+1+idlen+1+"(func".length, line.length-2)
        typedecls[Object.keys(typedecls).length] = typedecl
    } else if (line.startsWith(importprefix)) {
        var match = typeregex.exec(line)
        result.push(line.replace(typeregex, typedecls[parseInt(match[1])]))
    } else if (line.startsWith(exportprefix)) {
        line = line.split(" ")
        line[2] = "(func "+line[2]
        result.push(line.join(" "))//+")"
    } else if (line.startsWith(funcprefix)) {
        var match = typeregex.exec(line)
        result.push(line.replace(typeregex, typedecls[parseInt(match[1])]))
    } else if (!line.startsWith("(module") && line!=")" && line.length > 0){//!line.startsWith("(export") &&
        result.push("("+line+")")
    } else {
        result.push(line)
    }
}

//console.log(typedecls)
replaced = result.join("\n")
//console.log(replaced)

met.value = replaced


</script>
